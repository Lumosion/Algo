# 二分、贪心

<div align = "right">powered by <b>LJL</b></div>

## 二分查找

二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语： logarithmic search），是用来在一个有序数组中查找某一元素的算法。

### 工作原理

以在一个升序数组中查找一个数为例。 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小 于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查 找的值同理，只需到左侧查找。

### 时间复杂度

二分查找的最优时间复杂度为 $O(1)$。 二分查找的平均时间复杂度和最坏时间复杂度均为$O(\log n)$。因为在二分搜索过程中，算法每次都把查 询的区间减半，所以对于一个长度为 $n$ 的数组，至多会进行$O(\log n)$次查找。

**模板代码**

```c++
#define MAX 100
int arr[MAX];//被查找数组
int binary_search(int start, int end, int key)
{
    int ret = -1; // 未搜索到数据返回-1下标
    int mid;
    while (start <= end)
    {
        mid = start + ((end - start) >> 1);
        if (arr[mid] < key)
            start = mid + 1;
        else if (arr[mid] > key)
            end = mid - 1;
        else
        { // 最后检测相等是因为多数搜索情况不是大于就是小于
            ret = mid;
            break;
        }
    }
    return ret; // 单一出口
}
```



## 二分答案

解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条 件。把这里的枚举换成二分，就变成了“二分答案”。

### 最大值最小化

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满 足这种条件，也可以看作是一种有序（如果把满足条件看做 ，不满足看做 ，至少对于这个条件的这一 维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答 案的「最大值」，然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。因 此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：

1. 答案在一个固定区间内；

2. 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；

3. 可行解对于区间满足一定的单调性。换言之，如果 是符合条件的，那么有 或者 也符合 条件。（这样下来就满足了上面提到的单调性）

最小值最大化是同理的。

**模板代码**

```c++
bool check(int x)
{ /* ... */
} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            r = mid; // check()判断mid是否满足性质
        else
            l = mid + 1;
    }
    return l;
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid))
            l = mid;
        else
            r = mid - 1;
    }
    return l;
}
```



## 贪心

贪心算法（英语：greedy algorithm），是用计算机来模拟一个“贪心”的人做出决策的过程。这个人十 分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后 可能造成的影响。

可想而知，**并不是所有的时候贪心法都能获得最优解**，所以一般使用贪心法的时候，都要确保自己能证 明其正确性。

### 适用范围

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问 题的最优解能递推到最终问题的最优解。

### 证明方法

贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

1. **反证法**：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目 前的解已经是最优解了。 
2. **归纳法**：先算得出边界情况（例如 ）的最优解 ，然后再证明：对于每个 ， 都可 以由 推导出结果。

### 题型

在提高组难度以下的题目中，最常见的贪心有两种。 

1. 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。 
2. 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优 化，比如用优先队列维护）

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

### 排序解法

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的 方法求出最优值。

### 后悔解法

思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这 个选项；否则，正式接受。如此往复。
