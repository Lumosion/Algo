# 枚举、递归

<div align = "right">powered by <b>LJL</b></div>

## 枚举

枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。

 枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

### 基本思路

1. 确定枚举对象、范围和判定条件。
2. 逐一枚举可能的解并验证每个解是否是问题的解。

### 要点

- #### 给出解空间

建立简洁的数学模型。 

枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素？

- #### 减少枚举的空间

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

- #### 选择合适的枚举顺序

根据题目判断。比如题目中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。



#### 例题

------

> 一个数组中的数互不相同，求其中和为0的数对的个数。

**直接枚举**

```c++
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
        if (a[i] + a[j] == 0)
            ans++;
```

以上代码中时间复杂度为 $O(n^2)$。

由于题中没要求数对是有序的，答案就是有序对的情况的两倍

对于这种，我们可以统计有序数对的数量，最后乘 $2$ 就是答案。

不妨要求配对的数要出现在靠前的位置

**优化枚举1**

```c++
for (int i = 0; i < n; i++)
    for (int j = 0; j < i; j++)
        ans++;
ans *= 2;
```

以上代码中关键代码执行次数为 $\frac {n(n-1)} {2}$。

我们来看看还能不能优化…… 

我们不一定要枚举第二个数，我们只需在枚举第一个数后，我们可以知道第二个数，我们只需确认第二个数是否存在，就省去了枚举第二个数的时间；

**优化枚举2**

```C++
bool met[maxn * 2];
memset(met, 0, sizeof(met));
for (int i = 0; i < n; i++)
{
    if (met[maxn - a[i]])
        ans++;
    met[maxn + a[i]] = true;
}
```



## 递归

递归（英语：Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。

### 基本思想

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是 规模更小的子问题。

求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。 

递归代码最重要的两个特征：

1. 结束条件和自我调用。
2. 自我调用是在解决子问题，而结束条件定义了最简 子问题的答案。

**模板代码**

```c++
int func(传入数值)
{
    if (终止条件)
        return 最小子问题解;
    return func(缩小规模);
}
```

#### 缺点

在程序执行中，递归是利用堆栈来实现的。

每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。

而栈不是无限大的，当递归层数过多时，就会造成 栈溢出 的后果。 

显然有时候递归处理是高效的，比如归并排序；有时候是低效的，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。
